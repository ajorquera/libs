(function(c,i){typeof exports=="object"&&typeof module<"u"?i(exports,require("react/jsx-runtime"),require("react"),require("firebase/firestore")):typeof define=="function"&&define.amd?define(["exports","react/jsx-runtime","react","firebase/firestore"],i):(c=typeof globalThis<"u"?globalThis:c||self,i(c.react={},c["react/jsx-runtime"],c.react,c["firebase/firestore"]))})(this,function(c,i,d,a){"use strict";var A=Object.defineProperty;var F=(c,i,d)=>i in c?A(c,i,{enumerable:!0,configurable:!0,writable:!0,value:d}):c[i]=d;var w=(c,i,d)=>F(c,typeof i!="symbol"?i+"":i,d);function u(...n){return e=>n.reduce((t,o)=>o(t),e)}const s=(n,e)=>t=>(e.forEach(o=>{(t[n]??t[o])!==void 0&&(t[n]=t[n]??t[o])}),t),g=n=>e=>{const t={...e};return n.forEach(o=>delete t[o]),t};function R(n,{inmediate:e}={inmediate:!1}){const[t,o]=d.useState(null),[r,l]=d.useState(null),[f,h]=d.useState(!1),m=d.useRef(!0);d.useEffect(()=>()=>{m.current=!1},[]);const y=d.useCallback(async(...p)=>{m.current&&(h(!0),l(null),o(null),n(...p).then(b=>o(b)).catch(b=>l(b)).finally(()=>h(!1)))},[n]);return d.useEffect(()=>{e&&y()},[e,y]),{data:t,error:r,loading:f,execute:y}}const P=n=>{const e=u(s("marginTop",["marginTop","mt","my"]),s("marginRight",["marginRight","mr","mx"]),s("marginBottom",["marginBottom","mb","my"]),s("marginLeft",["marginLeft","ml","mx"]),s("margin",["margin","m"]))({...n});return{...g(["marginTop","marginRight","marginBottom","marginLeft","margin","mt","mr","mb","ml","my","mx"])(n),style:{...n.style,...e}}},x=n=>{const e=u(s("paddingTop",["paddingTop","pt","py"]),s("paddingRight",["paddingRight","pr","px"]),s("paddingBottom",["paddingBottom","pb","py"]),s("paddingLeft",["paddingLeft","pl","px"]),s("padding",["padding","p"]))({...n});return{...g(["paddingTop","paddingRight","paddingBottom","paddingLeft","padding","pt","pr","pb","pl","px","py"])(n),style:{...n.style,...e}}},B=n=>{const e=u(s("width",["width","w"]),s("height",["height","h"]),s("minWidth",["minWidth","minW"]),s("minHeight",["minHeight","minH"]))({...n});return{...g(["width","height","minWidth","minHeight"])(n),style:{...n.style,...e}}},T=n=>{const e=u(s("borderTop",["borderTop","borderY"]),s("borderRight",["borderRight","borderX"]),s("borderBottom",["borderBottom","borderY"]),s("borderLeft",["borderLeft","borderX"]))({...n});return{...g(["borderTop","borderRadius","borderRight","borderBottom","borderLeft","borderY","borderX"])(e),style:{...n.style,...e}}},L=n=>{const e=u(s("backgroundColor",["backgroundColor","bg"]))({...n});return{...g(["backgroundColor","bg"])(n),style:{...e,...n.style}}},S=({as:n,style:e,...t})=>{const o=u(P,x,B,T,L)(t),r=n??"div";return i.jsx(r,{...o,style:{...o.style,...e}})},q=()=>i.jsx("span",{children:"Text"}),v=({children:n,...e})=>i.jsx("button",{...e,children:n}),j=(n,e)=>n.reduce((t,o)=>(t[o.name]=e,t),{}),C=n=>async(e,t)=>{const o=Object.fromEntries(t.entries());n(o)},D=({onSubmit:n,error:e,fields:t,componentMap:o})=>{const[r,l,f]=d.useActionState(C(n),j(t,"")),h=e||Object.values(r).pop();return i.jsxs("form",{action:l,children:[t.map((m,y)=>{const p=o[m.type]??o.default;return i.jsx(p,{label:m.label,...m.options},y)}),h&&i.jsx(q,{children:h}),i.jsx(v,{type:"submit",children:f?"Loading...":"Submit"})]})};class E{constructor(e,t){w(this,"collectionName");this.collectionRef=e,this.db=t,this.collectionName=this.collectionRef.path}query(e){return(...t)=>{let o;if(typeof t[0]=="string"){const[r]=t;o=a.doc(e,r)}else if(t.some(r=>r.every(Boolean))){const r=t.map(l=>a.where(...l));o=a.query(e,...r)}else o=a.query(e);return o}}async create(e){const t=a.doc(this.collectionRef),o={...e,id:t.id,createdAt:a.Timestamp.now()};return await a.setDoc(t,o),o}async read(e){const t=a.doc(this.collectionRef,e);let o;if(e){const r=await a.getDoc(t);r.exists()&&(o=r.data())}else{const r=await a.getDocs(this.collectionRef);r.empty||(o=r.docs.map(l=>l.data()))}return o}async update(e,t){const o=a.doc(this.collectionRef,e);await a.setDoc(o,t,{merge:!0})}async delete(e){const t=a.doc(this.collectionRef,e);await a.deleteDoc(t)}async deleteAll(...e){const t=e.map(r=>a.where(...r)),o=await a.getDocs(a.query(this.collectionRef,...t));if(this.db||console.error("db is not available"),!o.empty&&this.db){const r=a.writeBatch(this.db);o.forEach(l=>{r.delete(l.ref)}),await r.commit()}}}c.Box=S,c.FireCrud=E,c.Form=D,c.useAsync=R,Object.defineProperty(c,Symbol.toStringTag,{value:"Module"})});
